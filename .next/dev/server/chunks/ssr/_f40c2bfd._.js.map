{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 31, "column": 0}, "map": {"version":3,"sources":["file:///Users/victorhachkajlo/Desktop/new-project/src/app/modules/home/home.module.tsx"],"sourcesContent":["'use client'\n\nimport { useTranslations } from 'next-intl'\nimport { type FC, useState } from 'react'\n\nimport { BooksListBlockComponent, SearchFormBlockComponent } from '@/app/features/block'\nimport { BannerComponent } from '@/app/shared/ui'\n\n// interface\ninterface IProps {\n  searchQuery?: string\n}\n\n// component\nconst HomeModule: FC<Readonly<IProps>> = (props) => {\n  const { searchQuery: initialSearchQuery = '' } = props\n  const [searchQuery, setSearchQuery] = useState(initialSearchQuery)\n\n  const t = useTranslations()\n\n  const handleSearch = (query: string) => {\n    setSearchQuery(query)\n  }\n\n  // return\n  return (\n    <div className='space-y-6'>\n      <div>\n        <BannerComponent />\n        <h1 className='text-2xl font-bold'>{t('home.title')}</h1>\n        <p>{t('home.subtitle')}</p>\n      </div>\n\n      <div className='flex justify-center'>\n        <SearchFormBlockComponent onSearch={handleSearch} initialValue={searchQuery} />\n      </div>\n\n      <BooksListBlockComponent searchQuery={searchQuery} />\n    </div>\n  )\n}\n\nexport default HomeModule\n"],"names":[],"mappings":";;;;;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AANA;;;;;;AAaA,YAAY;AACZ,MAAM,aAAmC,CAAC;IACxC,MAAM,EAAE,aAAa,qBAAqB,EAAE,EAAE,GAAG;IACjD,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,iNAAQ,EAAC;IAE/C,MAAM,IAAI,IAAA,yNAAe;IAEzB,MAAM,eAAe,CAAC;QACpB,eAAe;IACjB;IAEA,SAAS;IACT,qBACE,8OAAC;QAAI,WAAU;;0BACb,8OAAC;;kCACC,8OAAC,6NAAe;;;;;kCAChB,8OAAC;wBAAG,WAAU;kCAAsB,EAAE;;;;;;kCACtC,8OAAC;kCAAG,EAAE;;;;;;;;;;;;0BAGR,8OAAC;gBAAI,WAAU;0BACb,cAAA,8OAAC,sRAAwB;oBAAC,UAAU;oBAAc,cAAc;;;;;;;;;;;0BAGlE,8OAAC,kRAAuB;gBAAC,aAAa;;;;;;;;;;;;AAG5C;uCAEe","debugId":null}},
    {"offset": {"line": 123, "column": 0}, "map": {"version":3,"sources":["file:///Users/victorhachkajlo/Desktop/new-project/node_modules/%40tanstack/react-query/src/HydrationBoundary.tsx"],"sourcesContent":["'use client'\nimport * as React from 'react'\n\nimport { hydrate } from '@tanstack/query-core'\nimport { useQueryClient } from './QueryClientProvider'\nimport type {\n  DehydratedState,\n  HydrateOptions,\n  OmitKeyof,\n  QueryClient,\n} from '@tanstack/query-core'\n\nexport interface HydrationBoundaryProps {\n  state: DehydratedState | null | undefined\n  options?: OmitKeyof<HydrateOptions, 'defaultOptions'> & {\n    defaultOptions?: OmitKeyof<\n      Exclude<HydrateOptions['defaultOptions'], undefined>,\n      'mutations'\n    >\n  }\n  children?: React.ReactNode\n  queryClient?: QueryClient\n}\n\nexport const HydrationBoundary = ({\n  children,\n  options = {},\n  state,\n  queryClient,\n}: HydrationBoundaryProps) => {\n  const client = useQueryClient(queryClient)\n\n  const optionsRef = React.useRef(options)\n  React.useEffect(() => {\n    optionsRef.current = options\n  })\n\n  // This useMemo is for performance reasons only, everything inside it must\n  // be safe to run in every render and code here should be read as \"in render\".\n  //\n  // This code needs to happen during the render phase, because after initial\n  // SSR, hydration needs to happen _before_ children render. Also, if hydrating\n  // during a transition, we want to hydrate as much as is safe in render so\n  // we can prerender as much as possible.\n  //\n  // For any queries that already exist in the cache, we want to hold back on\n  // hydrating until _after_ the render phase. The reason for this is that during\n  // transitions, we don't want the existing queries and observers to update to\n  // the new data on the current page, only _after_ the transition is committed.\n  // If the transition is aborted, we will have hydrated any _new_ queries, but\n  // we throw away the fresh data for any existing ones to avoid unexpectedly\n  // updating the UI.\n  const hydrationQueue: DehydratedState['queries'] | undefined =\n    React.useMemo(() => {\n      if (state) {\n        if (typeof state !== 'object') {\n          return\n        }\n\n        const queryCache = client.getQueryCache()\n        // State is supplied from the outside and we might as well fail\n        // gracefully if it has the wrong shape, so while we type `queries`\n        // as required, we still provide a fallback.\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        const queries = state.queries || []\n\n        const newQueries: DehydratedState['queries'] = []\n        const existingQueries: DehydratedState['queries'] = []\n        for (const dehydratedQuery of queries) {\n          const existingQuery = queryCache.get(dehydratedQuery.queryHash)\n\n          if (!existingQuery) {\n            newQueries.push(dehydratedQuery)\n          } else {\n            const hydrationIsNewer =\n              dehydratedQuery.state.dataUpdatedAt >\n                existingQuery.state.dataUpdatedAt ||\n              (dehydratedQuery.promise &&\n                existingQuery.state.status !== 'pending' &&\n                existingQuery.state.fetchStatus !== 'fetching' &&\n                dehydratedQuery.dehydratedAt !== undefined &&\n                dehydratedQuery.dehydratedAt >\n                  existingQuery.state.dataUpdatedAt)\n\n            if (hydrationIsNewer) {\n              existingQueries.push(dehydratedQuery)\n            }\n          }\n        }\n\n        if (newQueries.length > 0) {\n          // It's actually fine to call this with queries/state that already exists\n          // in the cache, or is older. hydrate() is idempotent for queries.\n          // eslint-disable-next-line react-hooks/refs\n          hydrate(client, { queries: newQueries }, optionsRef.current)\n        }\n        if (existingQueries.length > 0) {\n          return existingQueries\n        }\n      }\n      return undefined\n    }, [client, state])\n\n  React.useEffect(() => {\n    if (hydrationQueue) {\n      hydrate(client, { queries: hydrationQueue }, optionsRef.current)\n    }\n  }, [client, hydrationQueue])\n\n  return children as React.ReactElement\n}\n"],"names":[],"mappings":";;;;;AACA,YAAY,WAAW;AAEvB,SAAS,eAAe;AACxB,SAAS,sBAAsB;;;;;AAoBxB,IAAM,oBAAoB,CAAC,EAChC,QAAA,EACA,UAAU,CAAC,CAAA,EACX,KAAA,EACA,WAAA,EACF,KAA8B;IAC5B,MAAM,aAAS,wMAAA,EAAe,WAAW;IAEzC,MAAM,aAAmB,+MAAA,CAAO,OAAO;IACjC,kNAAA,CAAU,MAAM;QACpB,WAAW,OAAA,GAAU;IACvB,CAAC;IAiBD,MAAM,iBACE,gNAAA,CAAQ,MAAM;QAClB,IAAI,OAAO;YACT,IAAI,OAAO,UAAU,UAAU;gBAC7B;YACF;YAEA,MAAM,aAAa,OAAO,aAAA,CAAc;YAKxC,MAAM,UAAU,MAAM,OAAA,IAAW,CAAC,CAAA;YAElC,MAAM,aAAyC,CAAC,CAAA;YAChD,MAAM,kBAA8C,CAAC,CAAA;YACrD,KAAA,MAAW,mBAAmB,QAAS;gBACrC,MAAM,gBAAgB,WAAW,GAAA,CAAI,gBAAgB,SAAS;gBAE9D,IAAI,CAAC,eAAe;oBAClB,WAAW,IAAA,CAAK,eAAe;gBACjC,OAAO;oBACL,MAAM,mBACJ,gBAAgB,KAAA,CAAM,aAAA,GACpB,cAAc,KAAA,CAAM,aAAA,IACrB,gBAAgB,OAAA,IACf,cAAc,KAAA,CAAM,MAAA,KAAW,aAC/B,cAAc,KAAA,CAAM,WAAA,KAAgB,cACpC,gBAAgB,YAAA,KAAiB,KAAA,KACjC,gBAAgB,YAAA,GACd,cAAc,KAAA,CAAM,aAAA;oBAE1B,IAAI,kBAAkB;wBACpB,gBAAgB,IAAA,CAAK,eAAe;oBACtC;gBACF;YACF;YAEA,IAAI,WAAW,MAAA,GAAS,GAAG;gBAIzB,IAAA,sLAAA,EAAQ,QAAQ;oBAAE,SAAS;gBAAW,GAAG,WAAW,OAAO;YAC7D;YACA,IAAI,gBAAgB,MAAA,GAAS,GAAG;gBAC9B,OAAO;YACT;QACF;QACA,OAAO,KAAA;IACT,GAAG;QAAC;QAAQ,KAAK;KAAC;IAEd,kNAAA,CAAU,MAAM;QACpB,IAAI,gBAAgB;YAClB,IAAA,sLAAA,EAAQ,QAAQ;gBAAE,SAAS;YAAe,GAAG,WAAW,OAAO;QACjE;IACF,GAAG;QAAC;QAAQ,cAAc;KAAC;IAE3B,OAAO;AACT","debugId":null}}]
}